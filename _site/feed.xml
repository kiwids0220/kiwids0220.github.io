<feed xmlns="http://www.w3.org/2005/Atom"> <id>http://localhost:4000/</id><title>林中木屋</title><subtitle>Just a student trying to learn everyday</subtitle> <updated>2024-03-04T18:15:21-06:00</updated> <author> <name>Kiwi</name> <uri>http://localhost:4000/</uri> </author><link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="http://localhost:4000/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 Kiwi </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Deep Diving into Nyx Part II - QEMU QOM Initialization</title><link href="http://localhost:4000/posts/Nyx-Deep-Dive-Part-2/" rel="alternate" type="text/html" title="Deep Diving into Nyx Part II - QEMU QOM Initialization" /><published>2024-02-19T00:00:00-06:00</published> <updated>2024-02-21T20:42:00-06:00</updated> <id>http://localhost:4000/posts/Nyx-Deep-Dive-Part-2/</id> <content src="http://localhost:4000/posts/Nyx-Deep-Dive-Part-2/" /> <author> <name>Kiwi</name> </author> <category term="Virtualization" /> <category term="Nyx" /> <category term="Internal" /> <summary> QEMU Initialization After setting up the debugger and mess around within the QEMU-Nyx, I found a couple of interesting spots that might worth documenting. QEMU Class Type Registration QEMU before starts the main() function will initialize these devices into its corresponding list using QEMU Object Model (QOM), for details of the process, please see here. You can find the init_type_list vari... </summary> </entry> <entry><title>Deep Diving into Nyx Part I - The Setup</title><link href="http://localhost:4000/posts/Nyx-Deep-Dive-Part-1/" rel="alternate" type="text/html" title="Deep Diving into Nyx Part I - The Setup" /><published>2024-02-19T00:00:00-06:00</published> <updated>2024-02-20T21:47:53-06:00</updated> <id>http://localhost:4000/posts/Nyx-Deep-Dive-Part-1/</id> <content src="http://localhost:4000/posts/Nyx-Deep-Dive-Part-1/" /> <author> <name>Kiwi</name> </author> <category term="Virtualization" /> <category term="Nyx" /> <category term="Internal" /> <summary> The Setup Clone &amp;amp; Compare I figured the best way to learn what modification that the Nyx has made on top of QEMU is to cloning both repos and compare all files that has been modified/added/deleted. To do so, I used a visual studio code extension Diff Folders (Extension ID: L13RARY.l13-diff) NOTE: The Nyx QEMU is based off of QEMU 4.2.0, which you can find the in branch named stable-4.... </summary> </entry> <entry><title>Useful Pwndbg &amp; WinDbg Commands</title><link href="http://localhost:4000/posts/Useful-Pwndbg-&amp;-WinDbg-Commands/" rel="alternate" type="text/html" title="Useful Pwndbg &amp;amp; WinDbg Commands" /><published>2024-02-11T00:00:00-06:00</published> <updated>2024-02-20T13:05:18-06:00</updated> <id>http://localhost:4000/posts/Useful-Pwndbg-&amp;-WinDbg-Commands/</id> <content src="http://localhost:4000/posts/Useful-Pwndbg-&amp;-WinDbg-Commands/" /> <author> <name>Kiwi</name> </author> <category term="Debugging" /> <summary> Windbg to Pwndbg Thanks to the Pwndbg dev team, users coming from Windbg will find pwndbg quite handy with the db, dt, dq, dq, etc... flags in Pwndbg. I really like the dt flag that will print out the type given a variable name. I also like ptype command which will print the type of the variable pwndbg&amp;gt; ptype fast_reload_t type = struct fast_reload_s { FastReloadMemoryMode mode; s... </summary> </entry> <entry><title>Debugging kAFL, A Snapshot-based Fuzzer</title><link href="http://localhost:4000/posts/notestest/" rel="alternate" type="text/html" title="Debugging kAFL, A Snapshot-based Fuzzer" /><published>2024-01-31T00:00:00-06:00</published> <updated>2024-01-31T00:00:00-06:00</updated> <id>http://localhost:4000/posts/notestest/</id> <content src="http://localhost:4000/posts/notestest/" /> <author> <name>Kiwi</name> </author> <category term="Virtualization" /> <category term="kAFL" /> <summary> test 123123 </summary> </entry> <entry><title>Debugging kAFL, A Snapshot-based Fuzzer</title><link href="http://localhost:4000/posts/Debugging_KAFL_A_SNAPSHOTBASED_FUZZER/" rel="alternate" type="text/html" title="Debugging kAFL, A Snapshot-based Fuzzer" /><published>2024-01-31T00:00:00-06:00</published> <updated>2024-02-22T10:53:14-06:00</updated> <id>http://localhost:4000/posts/Debugging_KAFL_A_SNAPSHOTBASED_FUZZER/</id> <content src="http://localhost:4000/posts/Debugging_KAFL_A_SNAPSHOTBASED_FUZZER/" /> <author> <name>Kiwi</name> </author> <category term="Virtualization" /> <category term="kAFL" /> <summary> kAFL Right of the bat, these sources act as the single sources of truth if you want to get a deeper understanding of kAFL: kAFL White Paper kAFL Doc What’s the blogpost about? Recently, I wanted to dive into the world of fuzzing, espcially kernel fuzzing, which is what led me to this project. I knew nothing about Fuzzing, what’s a fuzzer, harness, corpus, frontend, backend, mutator, snapshot... </summary> </entry> </feed>
