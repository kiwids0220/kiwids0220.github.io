[ { "title": "NT Filesystem Internals Study Notes", "url": "/posts/NT-Filesystem-Internals-Study-Notes/", "categories": "Notes", "tags": "notes", "date": "2024-03-04 00:00:00 -0600", "snippet": "The BookNotesSpin Locks Spin lock are used to lock shared data to make sure there’s only one thread executed by one processor to access it. Dispatcher objects are provided by the kernel...", "content": "The BookNotesSpin Locks Spin lock are used to lock shared data to make sure there’s only one thread executed by one processor to access it. Dispatcher objects are provided by the kernel to the Executives Dispatch Obj vs Spin lock: Spin lock will keep trying to require the lock, dispatcher object will put the thread to suspended stateMutex vs Event Event doesn’t provide the mutual exclusiveness between threads executed by processors while Mutex and Spin locks doNT I/O Manager Execution Context the kernel driver’s code may be executed by many other threads outside of the context of the driver This is important because depending on their context, they might not have access to other resources or have knowledge of. The Context of a user-mode thread that has requested system services : the code will often execute in the context of the user-mode thread that requests any I/O operations (e.x., Read File) The context of the dedicated worker thread created by the drive, or by some kernel-mode component. They can do so by invoking PsCreateSAystemThread(). The context of system worker threads specially created by the I/O manager to serve I/O subsystem components. Usually happens in the Async I/O requests. from user-mode applications. The request will be picked up and handled by a system worker thread. " }, { "title": "Deep Diving into Nyx Part II - QEMU QOM Initialization", "url": "/posts/Nyx-Deep-Dive-Part-2/", "categories": "Virtualization, Nyx, Internal", "tags": "QEMU", "date": "2024-02-19 00:00:00 -0600", "snippet": "QEMU InitializationAfter setting up the debugger and mess around within the QEMU-Nyx, I found a couple of interesting spots that might worth documenting.QEMU Class Type RegistrationQEMU before sta...", "content": "QEMU InitializationAfter setting up the debugger and mess around within the QEMU-Nyx, I found a couple of interesting spots that might worth documenting.QEMU Class Type RegistrationQEMU before starts the main() function will initialize these devices into its corresponding list using QEMU Object Model (QOM), for details of the process, please see here. You can find the init_type_list variable and add it to the WatchThe list is initialized by all type_init() macros which will be called before main() thanks for the constructor attribute :#define type_init(function) module_init(function, MODULE_INIT_QOM)#define module_init(function, type) \\static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\{ \\ register_module_init(function, type); \\}#endiftype_init(nyx_interface_register_types)SummaryEach class in QEMU will call type_init to Register* themselves with QEMU and it will be inserted into init_type_list before main().QEMU Class Template InitializationAfter the list has been initialized. The class will be instantiated in vl.c:main() with select_machine()-&gt; object_class_get_list(TYPE_MACHINE, false); -&gt; object_class_foreach(object_class_get_list_tramp,implements_type, include_abstract, &amp;list); -&gt; g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &amp;data); -&gt; Hash table iteration -&gt; oject_class_foreach_tramp -&gt; object.c:type_initialize (where the all objects the class inherited from .parent) will get -&gt;ti-&gt;class_init -&gt; nyx_interface_class_init. Here is the good graph from terenceil with an example of VMXNET3ClassSummaryDuring select_machine() call, all the classes that has registered with QEMU will be initialized by caling their corrsponding ##_class_init() funtions. Now with all class template has been initialized, user can now instantiate them.QEMU Chardev InstantiationFollowing the classes initialization, the main() continues to parse the user supplied devices/chardevs arguments . In the kAFL case, the first is \"-chardev\", \"socket,server,id=nyx_socket,path=/tmp/kafl_kiwi/interface_0\", which the main() has a block for initializing all chardev the user wantqemu_opts_foreach(qemu_find_opts(\"chardev\"),chardev_init_func, NULL, &amp;error_fatal);qemu_opts_foreach(qemu_find_opts(\"chardev\"),chardev_init_func, NULL, &amp;error_fatal);static int chardev_init_func(void *opaque, QemuOpts *opts, Error **errp){ Error *local_err = NULL; if (!qemu_chr_new_from_opts(opts, NULL, &amp;local_err)) { if (local_err) { error_propagate(errp, local_err); return -1; } exit(0); } return 0;}The qemu_find_opts(\"chardev\") function is grabbing the correct list from vm_config_groups by comparing the .name, in this case “chardev”, after that it will call chardev_init_func -&gt; qemu_chr_new_from_opts().Chardev *qemu_chr_new_from_opts(QemuOpts *opts, GMainContext *context, Error **errp){ const ChardevClass *cc; Chardev *chr = NULL; ChardevBackend *backend = NULL; const char *name = chardev_alias_translate(qemu_opt_get(opts, \"backend\")); const char *id = qemu_opts_id(opts); char *bid = NULL; if (name &amp;&amp; is_help_option(name)) { GString *str = g_string_new(\"\"); chardev_name_foreach(help_string_append, str); qemu_printf(\"Available chardev backend types: %s\\n\", str-&gt;str); g_string_free(str, true); return NULL; } if (id == NULL) { error_setg(errp, \"chardev: no id specified\"); return NULL; }\t//Returns a CharDevBackend backend = qemu_chr_parse_opts(opts, errp); if (backend == NULL) { return NULL; } cc = char_get_class(name, errp); if (cc == NULL) { goto out; } if (qemu_opt_get_bool(opts, \"mux\", 0)) { bid = g_strdup_printf(\"%s-base\", id); } chr = qemu_chardev_new(bid ? bid : id, object_class_get_name(OBJECT_CLASS(cc)), backend, context, errp); if (chr == NULL) { goto out; } if (bid) { Chardev *mux; qapi_free_ChardevBackend(backend); backend = g_new0(ChardevBackend, 1); backend-&gt;type = CHARDEV_BACKEND_KIND_MUX; backend-&gt;u.mux.data = g_new0(ChardevMux, 1); backend-&gt;u.mux.data-&gt;chardev = g_strdup(bid); mux = qemu_chardev_new(id, TYPE_CHARDEV_MUX, backend, context, errp); if (mux == NULL) { object_unparent(OBJECT(chr)); chr = NULL; goto out; } chr = mux; }out: qapi_free_ChardevBackend(backend); g_free(bid); return chr;}qemu_chr_new_from_opts will call multiple functions to setup our ChardevBackend and finally assemble the backend device with our chardev frontend. Here is the breakdown of each function:ChardevBackend *qemu_chr_parse_opts(QemuOpts *opts, Error **errp){ Error *local_err = NULL; const ChardevClass *cc; ChardevBackend *backend = NULL; const char *name = chardev_alias_translate(qemu_opt_get(opts, \"backend\")); if (name == NULL) { error_setg(errp, \"chardev: \\\"%s\\\" missing backend\", qemu_opts_id(opts)); return NULL; } cc = char_get_class(name, errp); if (cc == NULL) { return NULL; } backend = g_new0(ChardevBackend, 1); backend-&gt;type = CHARDEV_BACKEND_KIND_NULL; if (cc-&gt;parse) { cc-&gt;parse(opts, backend, &amp;local_err); if (local_err) { error_propagate(errp, local_err); qapi_free_ChardevBackend(backend); return NULL; } } else { ChardevCommon *ccom = g_new0(ChardevCommon, 1); qemu_chr_parse_common(opts, ccom); backend-&gt;u.null.data = ccom; /* Any ChardevCommon member would work */ } return backend;}struct ChardevSocket { /* Members inherited from ChardevCommon: */ bool has_logfile; char *logfile; bool has_logappend; bool logappend; /* Own members: */ SocketAddressLegacy *addr; bool has_tls_creds; char *tls_creds; bool has_tls_authz; char *tls_authz; bool has_server; bool server; bool has_wait; bool wait; bool has_nodelay; bool nodelay; bool has_telnet; bool telnet; bool has_tn3270; bool tn3270; bool has_websocket; bool websocket; bool has_reconnect; int64_t reconnect;};The first function called is qemu_chr_parse_opts that checks for the backend device which in our case by comparing the name with all supported type of backends. Then it will create the ChardevBackend class which wraps around the actual ChardevSocket in our case.cc = char_get_class(name, errp); if (cc == NULL) { goto out; }ObjectClass *object_class_by_name(const char *typename){ TypeImpl *type = type_get_by_name(typename); if (!type) { return NULL; } type_initialize(type); return type-&gt;class;}static const ChardevClass *char_get_class(const char *driver, Error **errp){ ObjectClass *oc; const ChardevClass *cc; char *typename = g_strdup_printf(\"chardev-%s\", driver); oc = object_class_by_name(typename); g_free(typename); if (!object_class_dynamic_cast(oc, TYPE_CHARDEV)) { error_setg(errp, \"'%s' is not a valid char driver name\", driver); return NULL; } if (object_class_is_abstract(oc)) { error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"driver\", \"abstract device type\"); return NULL; } cc = CHARDEV_CLASS(oc); if (cc-&gt;internal) { error_setg(errp, \"'%s' is not a valid char driver name\", driver); return NULL; } return cc;}typedef struct ChardevClass { ObjectClass parent_class; bool internal; /* TODO: eventually use TYPE_USER_CREATABLE */ void (*parse)(QemuOpts *opts, ChardevBackend *backend, Error **errp); void (*open)(Chardev *chr, ChardevBackend *backend, bool *be_opened, Error **errp); int (*chr_write)(Chardev *s, const uint8_t *buf, int len); int (*chr_sync_read)(Chardev *s, const uint8_t *buf, int len); GSource *(*chr_add_watch)(Chardev *s, GIOCondition cond); void (*chr_update_read_handler)(Chardev *s); int (*chr_ioctl)(Chardev *s, int cmd, void *arg); int (*get_msgfds)(Chardev *s, int* fds, int num); int (*set_msgfds)(Chardev *s, int *fds, int num); int (*chr_add_client)(Chardev *chr, int fd); int (*chr_wait_connected)(Chardev *chr, Error **errp); void (*chr_disconnect)(Chardev *chr); void (*chr_accept_input)(Chardev *chr); void (*chr_set_echo)(Chardev *chr, bool echo); void (*chr_set_fe_open)(Chardev *chr, int fe_open); void (*chr_be_event)(Chardev *s, int event); /* Return 0 if succeeded, 1 if failed */ int (*chr_machine_done)(Chardev *chr);} ChardevClass;After the backend class has selected, the second function called is char_get_class() function which will first lookup the chardev-socket class with object_class_by_name(typename) during QEMU Class Template Initialization that we had previously initialized, if it’s not yet initialized then it calls type_initialize() on the spot. Note here that all related functions are populated to the class. As you will see later, the chardev object does not hold any of the functions. When QEMU uses the chardev, it will first get its class and invoke the corresponding functionsNext cc = CHARDEV_CLASS(oc); which then cast the ObjectClass into ChardevClasschr = qemu_chardev_new(bid ? bid : id, object_class_get_name(OBJECT_CLASS(cc)), backend, context, errp);Chardev *qemu_chardev_new(const char *id, const char *typename, ChardevBackend *backend, GMainContext *gcontext, Error **errp){ Object *obj; Chardev *chr = NULL; Error *local_err = NULL; bool be_opened = true; assert(g_str_has_prefix(typename, \"chardev-\")); obj = object_new(typename); chr = CHARDEV(obj); chr-&gt;label = g_strdup(id); chr-&gt;gcontext = gcontext; qemu_char_open(chr, backend, &amp;be_opened, &amp;local_err); if (local_err) { goto end; } if (!chr-&gt;filename) { chr-&gt;filename = g_strdup(typename + 8); } if (be_opened) { qemu_chr_be_event(chr, CHR_EVENT_OPENED); } if (id) { object_property_add_child(get_chardevs_root(), id, obj, &amp;local_err); if (local_err) { goto end; } object_unref(obj); }end: if (local_err) { error_propagate(errp, local_err); object_unref(obj); return NULL; } return chr;}qemu_chardev_new() will instantiate Chardev object* using object_new() with heap allocated memory and CHARDEV() .static void qemu_char_open(Chardev *chr, ChardevBackend *backend, bool *be_opened, Error **errp){ ChardevClass *cc = CHARDEV_GET_CLASS(chr); /* Any ChardevCommon member would work */ ChardevCommon *common = backend ? backend-&gt;u.null.data : NULL; if (common &amp;&amp; common-&gt;has_logfile) { int flags = O_WRONLY | O_CREAT; if (common-&gt;has_logappend &amp;&amp; common-&gt;logappend) { flags |= O_APPEND; } else { flags |= O_TRUNC; } chr-&gt;logfd = qemu_open(common-&gt;logfile, flags, 0666); if (chr-&gt;logfd &lt; 0) { error_setg_errno(errp, errno, \"Unable to open logfile %s\", common-&gt;logfile); return; } } if (cc-&gt;open) { cc-&gt;open(chr, backend, be_opened, errp); }}Finally, the Chardev* char is used to get the CharDevClass cc which the class holds many function pointers related to socket communications, such as qmp_chardev_open_socket.if (cc-&gt;open) { cc-&gt;open(chr, backend, be_opened, errp); }When the ChardevClass.open field is not NULL, then the function is called. The thread is now listening for communication on the socket.From the kAFL frontend fuzzer and we should see a new socket just got created in our $workdir NOTE: For chardev, you can specify their backend, in our case, we selected socket as our chardev backend.For the full supported backend options with qemu-system-x86_64 -chardev helpSummaryQEMU’s main() will parse the user arguments to instantiate chardev devices and call its open function if it has one.QEMU Device InstantiationSimilar to Chardev, another function is called in main():if (qemu_opts_foreach(qemu_find_opts(\"device\"), device_init_func, NULL, NULL)) { exit(1);}" }, { "title": "Deep Diving into Nyx Part I - The Setup", "url": "/posts/Nyx-Deep-Dive-Part-1/", "categories": "Virtualization, Nyx, Internal", "tags": "QEMU", "date": "2024-02-19 00:00:00 -0600", "snippet": "The SetupClone &amp; CompareI figured the best way to learn what modification that the Nyx has made on top of QEMU is to cloning both repos and compare all files that has been modified/added/delete...", "content": "The SetupClone &amp; CompareI figured the best way to learn what modification that the Nyx has made on top of QEMU is to cloning both repos and compare all files that has been modified/added/deleted. To do so, I used a visual studio code extension Diff Folders (Extension ID: L13RARY.l13-diff) NOTE: The Nyx QEMU is based off of QEMU 4.2.0, which you can find the in branch named stable-4.2 Here is the command line used to clone the repo git clone -b stable-4.2 https://github.com/qemu/qemu.git for QEMUgit clone https://github.com/nyx-fuzz/QEMU-Nyx.git for QEMU-NyxAfter that, should be easy to compare all the files that Nyx has added or modified, for example Capstonev4, Nyx folders appear as added foldersWhere Can I Start?Well, following my Debugging kAFL series, you know we have a example that we can debug and now it’s just a matter of stepping through the source code and learn some more about QEMU and Nyx (two bird with one stone).This time, I will not use GDB to debug but rather I will use VSCode to play on easy mode… The setup is quite simple, compile the QEMU-Nyx with┌[kiwish-4.2]-(Downloads/QEMU-Nyx)-[git:qemu-nyx-4.2.0*]-└&gt; ./compile_qemu_nyx.sh debug_staticAdding a configuration file into VS Code is simple enough, ask ChatGPT to convert out previous GDB command line to VS Code configuration{ \"version\": \"0.2\", \"configurations\": [ { \"name\": \"QEMU Debugging\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/x86_64-softmmu/qemu-system-x86_64\", \"args\": [ \"-enable-kvm\", \"-machine\", \"kAFL64-v1\", \"-cpu\", \"kAFL64-Hypervisor-v1,+vmx\", \"-no-reboot\", \"-net\", \"none\", \"-display\", \"none\", \"-chardev\", \"socket,server,id=nyx_socket,path=/tmp/kafl_kiwi/interface_0\", \"-device\", \"nyx,chardev=nyx_socket,workdir=/tmp/kafl_kiwi,worker_id=0,bitmap_size=65536,input_buffer_size=131072\", \"-device\", \"isa-serial,chardev=kafl_serial\", \"-chardev\", \"file,id=kafl_serial,mux=on,path=/tmp/kafl_kiwi/serial_00.log\", \"-m\", \"4096\", \"-drive\", \"file=/home/kiwi/.local/share/libvirt/images/windows_x86_64_vagrant-kafl-windows.img\", \"-fast_vm_reload\", \"path=/tmp/kafl_kiwi/snapshot/,load=off\", \"-device\", \"vmcoreinfo\", \"--monitor\", \"unix:qemu-monitor-socket,server,nowait\" ], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ] } ]}Okay, ClientWe can now run the QEMU-Nyx by starting the debug session, and set a break point at main() in vl.c In VSCode debug mode and we will now get all the symbol information and the ability to inspect variables within VS Code. Shoutout to Microsoft VSCode dev team!Well, we got our QEMU-Nyx running, but it’s still waiting on a actual client to supply the corpus and instruct the QEMU-Nye instance what to do.We will again use kAFL as our “QEMU-Nyx client” to initiate all workflow for us so we can focus on debugging the QEMU-Nyx. If you don’t know how to do that yet, please check the blogpost linked above. NOTE: When you try to inspect Global variables , you will need to add them to the Watch tab. Ex. global_state variable, right click on the variable and Add to Watch. NOTE: I had this trouble when I was inspecting the global_state global variable, but however, VS Code mapped the variable to another struct that’s in the original QEMU source code and I had to rename the Nyx’s global_state variable to something else to avoid name collisionPutting Everything Together Start the kAFL Fuzzer frontend Start the QEMU-Nyx Continue the execution of QEMU-Nyx and check the workdirto see if the interface_X socket is there. This is needed by kAFL to initialize the client handshake. Set desired breakpoints in QEMU-Nyx and continue kAFL execution. Ex. I set a breakpoint at nyx_interface device_realize function Have fun learning about QEMU and Nyx" }, { "title": "Useful Pwndbg & WinDbg Commands", "url": "/posts/Useful-Pwndbg-&-WinDbg-Commands/", "categories": "Debugging", "tags": "Pwndbg, WinDbg", "date": "2024-02-11 00:00:00 -0600", "snippet": "Windbg to PwndbgThanks to the Pwndbg dev team, users coming from Windbg will find pwndbg quite handy with the db, dt, dq, dq, etc... flags in Pwndbg. I really like the dt flag that will print out t...", "content": "Windbg to PwndbgThanks to the Pwndbg dev team, users coming from Windbg will find pwndbg quite handy with the db, dt, dq, dq, etc... flags in Pwndbg. I really like the dt flag that will print out the type given a variable name.I also like ptype command which will print the type of the variablepwndbg&gt; ptype fast_reload_ttype = struct fast_reload_s { FastReloadMemoryMode mode; shadow_memory_t *shadow_memory_state; snapshot_page_blocklist_t *blocklist; nyx_fdl_t *fdl_state; nyx_dirty_ring_t *dirty_ring_state; nyx_fdl_user_t *fdl_user_state; nyx_device_state_t *device_state; nyx_block_t *block_state; _Bool root_snapshot_created; _Bool incremental_snapshot_enabled; nyx_coverage_bitmap_copy_t *bitmap_copy; uint32_t dirty_pages;}info locals is another good one that can list Local variables of the current stack frame.Useful Windbg commandFinding dispatcher object (Event, mutex, etc…) Finding the usermode process !process 0 0 lsass.exe After finding the process address, list threads info and check those DISPATCHER_OBJECT !process ffff8005bd42c080 6 Checking the DISPATCHER_OBJECT HEADER dt nt!_DISPATCHER_HEADER ffff8005b84bd5a0 Finding the object with the name Given a object name kd&gt; !object \\SECURITY\\LSA_AUTHENTICATION_INITIALIZED Object: ffff8005b84bd5a0 Type: (ffff8005b84c1f00) Event ObjectHeader: ffff8005b84bd570 (new version) HandleCount: 1 PointerCount: 32770 Directory Object: ffffcc0a23c1c770 Name: LSA_AUTHENTICATION_INITIALIZED Highlight the Object address by Crtl + Left Click on the address ffff8005b84bd5a0 Search the handle table !findhandle ffff8005b84bd5a0 Validate the handle Directory objectChecking Nt!_KTHREAD for objects waitingkd&gt; dx -id 0,0,ffff8005bd42c080 -r1 ((ntdll!_KTHREAD *)0xffff8005bd393080)((ntdll!_KTHREAD *)0xffff8005bd393080) : 0xffff8005bd393080 [Type: _KTHREAD *]\t... [+0x0c8] WaitStatus : 0 [Type: __int64] [+0x0d0] WaitBlockList : 0xffff8005bd3931c0 [Type: _KWAIT_BLOCK *]\t...\tkd&gt; dt _KWAIT_BLOCK 0xffff8005bd3931c0ntdll!_KWAIT_BLOCK +0x000 WaitListEntry : _LIST_ENTRY [ 0xffff8005`b84bd5a8 - 0xffff8005`b84bd5a8 ] +0x010 WaitType : 0x1 '' +0x011 BlockState : 0x4 '' +0x012 WaitKey : 0 +0x014 SpareLong : 0n671 +0x018 Thread : 0xffff8005`bd393080 _KTHREAD - THREAD RUNNING HARNESS +0x018 NotificationQueue : 0xffff8005`bd393080 _KQUEUE +0x020 Object : 0xffff8005`b84bd5a0 Void - EVENT Object: LSA_AUTHENTICATION_INITIALIZED +0x028 SparePtr : (null) kd&gt; !object 0xffff8005`b84bd5a0Object: ffff8005b84bd5a0 Type: (ffff8005b84c1f00) Event ObjectHeader: ffff8005b84bd570 (new version) HandleCount: 1 PointerCount: 32770 Directory Object: ffffcc0a23c1c770 Name: LSA_AUTHENTICATION_INITIALIZEDChecking NT!_DISPACTHER_HEADER for thread waitingdt -r1 nt!_KEVENT ffff8005b84bd5a0 () Recursive: [ -r1 -r2 -r ] Verbose Normal dt================================================================================== +0x000 Header : _DISPATCHER_HEADER +0x000 Lock : 0n33947648 (0x2060000) +0x000 LockNV : 0n33947648 (0x2060000) +0x000 Type : 0 '' +0x001 Signalling : 0 '' +0x002 Size : 0x6 '' +0x003 Reserved1 : 0x2 '' +0x000 TimerType : 0 '' +0x001 TimerControlFlags : 0 '' +0x001 Absolute : 0y0 +0x001 Wake : 0y0 +0x001 EncodedTolerableDelay : 0y000000 (0) +0x002 Hand : 0x6 '' +0x003 TimerMiscFlags : 0x2 '' +0x003 Index : 0y000010 (0x2) +0x003 Inserted : 0y0 +0x003 Expired : 0y0 +0x000 Timer2Type : 0 '' +0x001 Timer2Flags : 0 '' +0x001 Timer2Inserted : 0y0 +0x001 Timer2Expiring : 0y0 +0x001 Timer2CancelPending : 0y0 +0x001 Timer2SetPending : 0y0 +0x001 Timer2Running : 0y0 +0x001 Timer2Disabled : 0y0 +0x001 Timer2ReservedFlags : 0y00 (0n0) +0x002 Timer2ComponentId : 0x6 '' +0x003 Timer2RelativeId : 0x2 '' +0x000 QueueType : 0 '' +0x001 QueueControlFlags : 0 '' +0x001 Abandoned : 0y0 +0x001 DisableIncrement : 0y0 +0x001 QueueReservedControlFlags : 0y000000 (0) +0x002 QueueSize : 0x6 '' +0x003 QueueReserved : 0x2 '' +0x000 ThreadType : 0 '' +0x001 ThreadReserved : 0 '' +0x002 ThreadControlFlags : 0x6 '' +0x002 CycleProfiling : 0y0 +0x002 CounterProfiling : 0y1 +0x002 GroupScheduling : 0y1 +0x002 AffinitySet : 0y0 +0x002 Tagged : 0y0 +0x002 EnergyProfiling : 0y0 +0x002 SchedulerAssist : 0y0 +0x002 ThreadReservedControlFlags : 0y0 +0x003 DebugActive : 0x2 '' +0x003 ActiveDR7 : 0y0 +0x003 Instrumented : 0y1 +0x003 Minimal : 0y0 +0x003 Reserved4 : 0y00 (0n0) +0x003 AltSyscall : 0y0 +0x003 UmsScheduled : 0y0 +0x003 UmsPrimary : 0y0 +0x000 MutantType : 0 '' +0x001 MutantSize : 0 '' +0x002 DpcActive : 0x6 '' +0x003 MutantReserved : 0x2 '' +0x004 SignalState : 0n0 +0x008 WaitListHead : _LIST_ENTRY [ 0xffff8005`bd3931c0 - 0xffff8005`bd3931c0 ] [EMPTY OR 1 ELEMENT]kd&gt; dt _KWAIT_BLOCK 0xffff8005`bd3931c0ntdll!_KWAIT_BLOCK +0x000 WaitListEntry : _LIST_ENTRY [ 0xffff8005`b84bd5a8 - 0xffff8005`b84bd5a8 ] +0x010 WaitType : 0x1 '' +0x011 BlockState : 0x4 '' +0x012 WaitKey : 0 +0x014 SpareLong : 0n671 +0x018 Thread : 0xffff8005`bd393080 _KTHREAD +0x018 NotificationQueue : 0xffff8005`bd393080 _KQUEUE +0x020 Object : 0xffff8005`b84bd5a0 Void +0x028 SparePtr : (null) " }, { "title": "Debugging kAFL, A Snapshot-based Fuzzer", "url": "/posts/Debugging_KAFL_A_SNAPSHOTBASED_FUZZER/", "categories": "Virtualization, kAFL", "tags": "fuzz", "date": "2024-01-31 00:00:00 -0600", "snippet": "kAFLRight of the bat, these sources act as the single sources of truth if you want to get a deeper understanding of kAFL:kAFL White PaperkAFL DocWhat’s the blogpost about?Recently, I wanted to dive...", "content": "kAFLRight of the bat, these sources act as the single sources of truth if you want to get a deeper understanding of kAFL:kAFL White PaperkAFL DocWhat’s the blogpost about?Recently, I wanted to dive into the world of fuzzing, espcially kernel fuzzing, which is what led me to this project. I knew nothing about Fuzzing, what’s a fuzzer, harness, corpus, frontend, backend, mutator, snapshot-based fuzzing. None of these made sense to me, so kAFL is the perfect project for me to dive in and learn about all those concepts.I wanted to utilize kAFL to fuzz Windows kernel drivers/core system component, but while the Github repo provided a great example for both fuzzing against the kernel mode target and the user mode target, I still find myself stuck in a suitiation where the fuzzer does not work the way I inteded. Well, the most important question is, how do we figure it out? The only answer is to start debugging..kAFL InfrastructureThe white paper ^ has nice explanation for kAFL’s internal infrastructure, you can also find it on their githubDebugging the kAFL Python FrontendThe frontend fuzzer kAFL itself is written in Python, and the vscode is prob the best option here to debug anything in Python. So I find the __main__.py and put a couple breakpointsUpon creating the Python debug configuration file and launching it with kafl fuzz, it hits those breakpoints but I was unable to continue debugging because the function qemu._connect() will fail due to a socket error. It turns out the frontend python script is communicating to the QEMU instance via UNIX Socket as documented in the kAFL documentation, and the socket was not yet established by QEMU-Nyx. So what can we do? The answer is easy, just start the QEMU instance ourselves.Doc├── interface_N - socket between kAFL worker N and Qemu NPatch kAFL Python FrontendThe kAFL fuzzer will prepare all the QEMU auguments internally and kick off the QEMU process for us. As you see in the screenshot above, I have commented out the subprocess which now the kADL will not do this. The reason is that While QEMU provides useful stub -S, -s for pausing the VM image at it’s first vCPU execution, we would still love to pause the QEMU process at the initialization phase (i.e., Machine/CPU/Peripheral initialization) which is the actual main() function in vl.c file (QEMU 4.2.0 release).So, we can tell the python script to pause at qemu.connect() and then start the QEMU-Nyx instance ourself -&gt; wait for the QEMU-Nyx socket to listen for connection -&gt; continue the frontend fuzzer -&gt; we can now continue the debugging processTo achieve this, I leveraged debugpy which is what vscode uses under the hood for python debuggingAnd the configuration fileBuilding QEMU-Nyx yourselfIf you look at the repo QEMU-Nyx, you will see it included a .sh script to build the QEMU-Nyx with a few options Here is the actual flags being passed to configureThis is done so that we can get the full symbol for the qemu-system-x86_64 and start debugging with gdb.Putting it togetherFollow the procedure of building your vm image using vagrant and ansible playbook -&gt; start the fuzzer with kafl fuzz --purge -w /tmp/whatever (-w for setting the working directory) -&gt; make sure the interface_0 unix socket exist in the folder, attach to the python script debugpy and start debugging.Getting Full System Dump While FuzzingThe kAFL patches the monitor/GUI interface when it starts, so we can’t really utilize the qemu monitor command line to snatch a full system memory dump while the fuzzer is running.Pausing Fuzzer And Collecting Memory DumpYou can technically “pause” the fuzzer and get your system dump there.To make sure the Windows guest vm is able to collect a full system memory dump in QEMU, we need to make sure that it installs the FwCfg driver which is included in the virt-io ISO installer, for more detailed instruction, I found this blog very helpful Guest Windows debugging and crashdumping under QEMU/KVM: dump-guest-memory, vmcoreinfo and virtio-winWell the trick to “pause” the fuzzer is simply reapplying what I talked about in the Putting It Together with another trick - using socat. The details is documented QEMU monitor with socat.Here is how you do it: We are still gonna run the same command line argument with our GDB/Pwndbg, but this time adding -device vmcoreinfo --monitor unix:qemu-monitor-socket,server,nowait at the endgdb --args \"./x86_64-softmmu/qemu-system-x86_64\" -enable-kvm -machine kAFL64-v1 -cpu kAFL64-Hypervisor-v1,+vmx -no-reboot -net none -display none -chardev socket,server,id=nyx_socket,path=/tmp/kafl_kiwi/interface_0 -device nyx,chardev=nyx_socket,workdir=/tmp/kafl_kiwi,worker_id=0,bitmap_size=65536,input_buffer_size=131072 -device isa-serial,chardev=kafl_serial -chardev file,id=kafl_serial,mux=on,path=/tmp/kafl_kiwi/serial_00.log -m 4096 -drive file=/home/kiwi/.local/share/libvirt/images/windows_x86_64_vagrant-kafl-windows.img -fast_vm_reload path=/tmp/kafl_kiwi/snapshot/,load=off -device vmcoreinfo --monitor unix:qemu-monitor-socket,server,nowait Kick off kAFL fuzzer frontend (patching out the subprocess.run that kick off another QEMU instance because we are doing it with gdb already) After the fuzzing loop starts, hit Crtl + C in gdb Go into the gdb directly, and connect to the QEMU monitor using socat -,echo=0,icanon=0 unix-connect:qemu-monitor-socket Run dump-guest-memory -w memory.dmp in the monitor CLI Continue the execution in gdbAfter that you should be able to collect a full system dumpDebugging the Windows Dump?This is not your typical dump you collected from a kernel panic crash or from WinDbg. This is the dump we collected via some additional loops in QEMU monitor. Since the dump we had is in WinDbg-compatible format, we can leverage WinDbg again to troubleshoot where the “Hang” comes from…Dump Analysis Using WinDbgWell, telling WinDbg to analyze our dump is quite easy, just simply drag and drop the .dmp file into WinDbg and run !analyze -v.After the WinDbg finished analyzing, we can find our harness by locating the process Ex.!process 0 0 lsass.exe.We may also list information regarding all threads running under our harness process with !process 0 7 lsass.exe Right off the bat, we find our thread that’s running our harness, however, it is at a wait stage as the WinDbg says:A couple of things worth noting: This is a Alertable event that the thread is waiting for. The NoficationEvent - Describe the type of Events. (more on Event objects can be found here and here)Please Wait()We know the thread is waiting for the Event to be “Signaled” so our thread can continue executing our harness. But what function lead to the NtWaitForSingleObjet(). The answer can be found yet again in the screenshot - Sspi!LsaRegisterLogonProcess(). LsaRegisterLogonProcess is a interesting function and Microsoft documented as The LsaRegisterLogonProcess function establishes a connection to the LSA server and verifies that the caller is a logon application.If we open the function in IDA, we will find where the call is made! Finding the Event in WinDbgIf you want to know how to find this “named” Event object in WinDbg dump, check out my other note.We will be utilizing some old MS WinDbg extension called Mex, Thanks for the people who made this extension and also @DebugPrivilege who documented the usefulness of it.Once you downloaded Mex and extracted to disk, run .load PATH_TO_MEX.dll in your WinDbg console.After that, we can utilize its !p to dump the process information given our lsass.exe address. Next, we can list all threads information by just clicking on the !mex.listthreadsWe found the same thread that was running our harness, and now let’s list more detail about the thread. Look, there’s our Event we just saw previously in IDA, and the name also matches.Now we can further inspect the Object by following the link of the address pointing to our NotificationEvent. The WaitBlockList is a field of nt!_THREAD struct which specifies a list of synchronization object that the thread is waiting on, find more info here.kAFL TimeoutPerhaps it was too early for the Event to be set for listening or the thread that’s supposed to signal the Event hasn’t done so (because of the “hacky” way I injected my harness), our harness thread was “hanging” at this point. Since kAFL is a snapshot-based fuzzer, it utilize QEMU-Nyx to achieve rapid VM reload at the point where the system snapshot was taken and when the execution ends. kAFL also specifies soft/hard timeouts for execution, if harness thread is blocked/put into a wait state, and if the thread was blocked for the duration that’s longer than the timeout, then the VM will be reset by the fuzzer. In this case, our Event was not signaled which caused our harness thread “hangs” virtually forever and kAFL resetted the VM, the infinite loop keeps on going…ClosingIt was very interesting diving into the fuzzer and troubleshoot our harness problem. This whole journey sparked my interested in Fuzzing, Hypervisor studies and I am excited for the future blog posts!Happy lunar new year and see you on the other side!" }, { "title": "Stalking inside of your Chromium Browser", "url": "/posts/Stalking-Inside_of_Your_chromium_Browser/", "categories": "redteam", "tags": "redteam", "date": "2022-12-01 00:00:00 -0600", "snippet": "Revisiting Remote DebuggingOkay, you got your favorite agent running on the target machine. You did a process listing, but nothing interesting popped out. You searched through every possible thing,...", "content": "Revisiting Remote DebuggingOkay, you got your favorite agent running on the target machine. You did a process listing, but nothing interesting popped out. You searched through every possible thing, even the trash bins to find a clue of where exactly the user hid their secrets that could get you to the user’s Azure portal.Well, Let’s revisit the process listing a little bit, do you see it? Is Chrome running with a bunch of child processes like this?Google Chrome ProcessesLook at that, the user is surfing the web with his/her favorite browser — Chrome!As a red teamer, I immediately thought of leveraging the remote debugging feature which is a built-in feature for all Chromium based browsers. This feature allows developers to troubleshoot using Chrome Remote Debugging Protocols (CDP) while they are doing the heavy lifting. A copy-paste description for CDP below.The Chrome DevTools Protocol allows for tools to instrument, inspect, debug and profile Chromium, Chrome and other Blink-based browsers. Instrumentation is divided into a number of domains (DOM, Debugger, Network etc.). Each domain defines a number of commands it supports and events it generates. Both commands and events are serialized JSON objects of a fixed structure.As red teamers, we can certainly abuse this feature to dump session cookies using the documented methodology by Justin Bui’s Hands in the Cookie Jar and an awesome python script called cookienapper.py written by Elliot Grey. But, what if the cookies expired? We just grabbed some spoiled cookies and we certainly can’t use them anywhere. Well, It will be nice if we can be notified when they log into Azure and refresh their cookies?To recap the technique used to dump cookies, we just need to quickly kill the Chrome process.kill ChromeprocessRestart it to enable remote debugging, restore the previous session and load the correct user profile.run \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --remote-debugging-port=9222 --user-data-dir=\"C:\\Users\\UserName\\AppData\\Local\\Google\\Chrome\\User Data\" --restore-last-sessionProxying [cookienapper.py](https://github.com/greycatsec/cookienapper) through a socks tunnel and profit!!socks 8081 socks5 proxychains4 python3 cookienapper.pyWe are almost there, but not yet. After inspecting the cookies we got from cookienapper, it turns out that the user was watching YouTube instead of working on Azure infrastructure deployments(a bad employee accidentally protected the company in an effortless way). So, the cookies we got were essentially useless.When will they start working !?Is there a way to possibly gather some information about users’ currently opened tabs without going through dumped cookies? It is mentioned in Hands in the Cookie Jar by Justin, the /json endpoint will provide us with more details of each opened tab.Information From /JSON EndpointThere are a couple of interesting fields that caught my eye, we can see the title of every tab the user has opened, and the url that the tab is currently browsing. Nice! We can sit here and refresh the “http://localhost:9222/json” page and filter out by title and URLs to see what the user is actually doing and hope the user will eventually log in to Azure so we can also enjoy the Azure cookies. Here, we can see the user is watching his/her favorite music video.There must be a better wayI eventually got tired of hitting the refresh button over and over, so I decided to look for alternative ways to monitor user activities. I revisited the cookienapper.py source code again and noticed that we were establishing a WebSocket connection to the “webSocketDebuggerUrl” and supplied a JSON string that looks like the following JSON{“id”:1, “method”:”Network.getAllCookies”}A quick google on the method “Network.getAllCookies” eventually led me to CDP documentation. It turns out, the method we were calling to dump cookies was just one of the commands supported by CDP.After going through some of the domains and methods provided in the document, I landed on the domain “Target”. The description of the domain says: “Supports additional target discovery and allows attaching to them.” After taking a closer look at the methods, there is one that caught my eyes called Target.setDiscoverTargets.Target.setDiscoverTargetsWhat is a “target”What are “targetCreated”, “targetInfoChanged”, “targetDestroyed”? In order to understand those, we must understand what is a “target”. This is a short conversation that explains “what is a target”, but I will also give my own understanding here. A “target” can be in the form of many types, such as “page”, or “iframe”. When you open a new tab in your browser, it creates a new blank “page” target, and when a page loads javascript, it creates a new “iframe” target. Each target will contain certain information about themselves such as “title”, “url”, “targetId” etc…When a new target is created, the “targetCreated” event is triggered. When a target’s information such as URL,or title changed, the “targetInfoChanged” event is triggered. When a target is destroyed, meaning the tabs are closed, the “targetDestroyed” event is triggered.Now what?After we understand the concept of “target”, the method will make much more sense. Essentially, If we keep the WebSocket alive long enough for the user to login to Azure, we will get tons of JSON response trigged from the above events.Let’s walk through them. The setup here I am using is Cobaltstrike socks5 proxy, a WebSocket client (wscat in this case). We can connect to a “webSocketDebuggerUrl” shown in “http://localhost:9222/json” that does not belong to a chrome-extension target (you can tell from the /json output url field, a chrome extension has a url with “chrome-extension://randomcharacters”).wscat -c ws://localhost:9222/devtools/page/7926E489B15E2BBE6531C458E4AE7232We will call the method with{“id”:2, “method”:”Target.setDiscoverTargets”, “params”:{“discover”:true}}We can see the WebSocket received a response with some more JSON strings containing information about all currently opened tabs and a result indicating the method has run successfully.Output from WebSocketWhen the user opens a new blank “target” page, the JSON response we will get from the WebSocket looks like this. We can see there are two methods called, “Target.targetCreated” and “Target.targetInfoChanged”.Output from WebSocketAnd when the user types “azure portal” in the url bar and hit Enter.User Searching “Azure Portal”We will get a couple more JSON responses that look like this.“Azure Portal” Keyword in Output from WebSocketAfter the user enetered the username to kick off the Oauth flow, we can also capture the username from the request URL.From the above response, we then know the user is currently logging into Azure and we can dump cookies again for fun and profit.More AutomationCool, so now we have a way to monitor user activity by asking the browser to give us live updates, but it will still require us to watch for the specific JSON response to really know when the user logins to something that we hope for.Is there a way to automate this? Of course. Here is a small PoC that I put together (heavily inspired by ntlmrelayx’s –socks flag) that will first send a GET request to “http://localhost:9222/json” on the remote host debugging port, create a WebSocket and connect to a “webSocketDebuggerUrl”. When you type “setDiscoveryTargets” and hit Enter, it will create a new thread that sends the “Target.setDiscoverTargets” command, listens for JSON responses and print them out by “type” and outputs useful information such as “URL”, and “title”. When you are ready to dump cookies, simply type “getCookies” and hit Enter, it will run cookienapper for you.Example Usage of agentChromium.pyThis is just a small PoC and there is more that can be done. For example, we can also add an event trigger that kicks off cookienapper when the title contains certain keywords.Detections Detect Chrome processes created by a unusual process Monitor for command line argument created with Chrome process to see if it is trying to enable remote debugging feature A GET request sends to /json with a abnormal user-agentsConclusionTo conclude, chromium-based browsers have become the new favorite for red teamers. This is just a demonstration of how one can combine multiple commands supported by CDP to save time and increase efficiency in a red team engagement.There are lots of excellent projects that leverage remote debugging features to achieve different purposes, and there are still plenty of commands left unexplored.Thank you for taking the time to read this blog post of mine. I hope you learned something new from this!" } ]
