[
  
  {
    "title": "Debugging kAFL, A Snapshot-based Fuzzing - Part II",
    "url": "/posts/Debugging_KAFL_A_SNAPSHOTBASED_FUZZER-2/",
    "categories": "Virtualization, QEMU-NYX, kAFL",
    "tags": "fuzz",
    "date": "2024-02-13 00:00:00 -0600",
    





    
    "snippet": "QEMU referencesGetting a full system dump while fuzzingThe kAFL patches the monitor/GUI interface when it starts, so we can’t really utilize the qemu monitor command line to snatch a full system me...",
    "content": "QEMU referencesGetting a full system dump while fuzzingThe kAFL patches the monitor/GUI interface when it starts, so we can’t really utilize the qemu monitor command line to snatch a full system memory dump while the fuzzer is running.Pausing Fuzzer and Collecting memory dumpYou can technically “pause” the fuzzer and get your system dump there.To make sure the Windows guest vm is able to collect a full system memory dump in QEMU, we need to make sure that it installs the FwCfg driver which is included in the virt-io ISO installer, for more detailed instruction, I found this blog very helpful Guest Windows debugging and crashdumping under QEMU/KVM: dump-guest-memory, vmcoreinfo and virtio-winWell the trick to “pause” the fuzzer is simply reapplying what I talked about in the Part I  with another trick - using socat. The details is documented QEMU monitor with socat.Here is how you do it:  We are still gonna run the same command line argument with our GDB/Pwndbg, but this time adding -device vmcoreinfo --monitor unix:qemu-monitor-socket,server,nowait at the endgdb --args \"./x86_64-softmmu/qemu-system-x86_64\" -enable-kvm -machine kAFL64-v1 -cpu kAFL64-Hypervisor-v1,+vmx -no-reboot -net none -display none -chardev socket,server,id=nyx_socket,path=/tmp/kafl_kiwi/interface_0 -device nyx,chardev=nyx_socket,workdir=/tmp/kafl_kiwi,worker_id=0,bitmap_size=65536,input_buffer_size=131072 -device isa-serial,chardev=kafl_serial -chardev file,id=kafl_serial,mux=on,path=/tmp/kafl_kiwi/serial_00.log -m 4096 -drive file=/home/kiwi/.local/share/libvirt/images/windows_x86_64_vagrant-kafl-windows.img -fast_vm_reload path=/tmp/kafl_kiwi/snapshot/,load=off -device vmcoreinfo --monitor unix:qemu-monitor-socket,server,nowait  Kick off kAFL fuzzer frontend (patching out the subprocess.run that kick off another QEMU instance because we are doing it with gdb already)  After the fuzzing loop starts, hit Crtl + C in gdb  Go into the gdb directly, and connect to the QEMU monitor using socat -,echo=0,icanon=0 unix-connect:qemu-monitor-socket  Run dump-guest-memory -w memory.dmp in the monitor CLI  Continue the execution in gdbAfter that you should be able to collect a full system dump"
  },
  
  {
    "title": "Useful Pwndbg & WinDbg Commands",
    "url": "/posts/Useful-Pwndbg-&-WinDbg-Commands/",
    "categories": "Debugging, Pwndbg, WinDbg",
    "tags": "Pwndbg, WinDbg",
    "date": "2024-02-11 00:00:00 -0600",
    





    
    "snippet": "Windbg to PwndbgThanks to the Pwndbg dev team, users coming from Windbg will find pwndbg quite handy with the db, dt, dq, dq, etc... flags in Pwndbg. I really like the dt flag that will print out t...",
    "content": "Windbg to PwndbgThanks to the Pwndbg dev team, users coming from Windbg will find pwndbg quite handy with the db, dt, dq, dq, etc... flags in Pwndbg. I really like the dt flag that will print out the type given a variable name.I also like ptype command which will print the type of the variablepwndbg&gt; ptype fast_reload_ttype = struct fast_reload_s {    FastReloadMemoryMode mode;    shadow_memory_t *shadow_memory_state;    snapshot_page_blocklist_t *blocklist;    nyx_fdl_t *fdl_state;    nyx_dirty_ring_t *dirty_ring_state;    nyx_fdl_user_t *fdl_user_state;    nyx_device_state_t *device_state;    nyx_block_t *block_state;    _Bool root_snapshot_created;    _Bool incremental_snapshot_enabled;    nyx_coverage_bitmap_copy_t *bitmap_copy;    uint32_t dirty_pages;}info locals is another good one that can list Local variables of the current stack frame.Useful Windbg commandFinding dispatcher object (Event, mutex, etc…)  Finding the usermode process    !process 0 0 lsass.exe        After finding the process address, list threads info and check those DISPATCHER_OBJECT    !process ffff8005bd42c080 6            Checking the DISPATCHER_OBJECT HEADER    dt nt!_DISPATCHER_HEADER ffff8005b84bd5a0      Finding the object with the name  Given a object name      kd&gt; !object \\SECURITY\\LSA_AUTHENTICATION_INITIALIZED  Object: ffff8005b84bd5a0  Type: (ffff8005b84c1f00) Event      ObjectHeader: ffff8005b84bd570 (new version)      HandleCount: 1  PointerCount: 32770      Directory Object: ffffcc0a23c1c770  Name: LSA_AUTHENTICATION_INITIALIZED               Highlight the Object address by Crtl + Left Click on the address ffff8005b84bd5a0        Search the handle table !findhandle ffff8005b84bd5a0    Validate the handle  Directory object"
  },
  
  {
    "title": "Debugging kAFL, A Snapshot-based Fuzzing - Part I",
    "url": "/posts/Debugging_KAFL_A_SNAPSHOTBASED_FUZZER/",
    "categories": "Virtualization, QEMU-NYX, kAFL",
    "tags": "fuzz",
    "date": "2024-01-31 00:00:00 -0600",
    





    
    "snippet": "kAFLRight of the bat, these sources act as the single sources of truth if you want to get a deeper understanding of kAFL:kAFL White PaperkAFL DocWhat’s the blogpost about?Recently, I wanted to dive...",
    "content": "kAFLRight of the bat, these sources act as the single sources of truth if you want to get a deeper understanding of kAFL:kAFL White PaperkAFL DocWhat’s the blogpost about?Recently, I wanted to dive into the world of fuzzing, espcially kernel fuzzing, which is what led me to this project. I knew nothing about Fuzzing, what’s a fuzzer, harness, corpus, frontend, backend, mutator, snapshot-based fuzzing. None of these made sense to me, so kAFL is the perfect project for me to dive in and learn about all those concepts.I wanted to utilize kAFL to fuzz Windows kernel drivers/core system component, but while the Github repo provided a great example for both fuzzing against the kernel mode target and the user mode target, I still find myself stuck in a suitiation where the fuzzer does not work the way I inteded. Well, the most important question is, how do we figure it out? The only answer is to start debugging..InfrastructureThe white paper ^ has nice explanation for kAFL’s internal infrastructure, you can also find it on their githubDebugging the frontendThe frontend fuzzer kAFL itself is written in Python, and the vscode is prob the best option here to debug anything in Python. So I find the __main__.py and put a couple breakpointsUpon creating the Python debug configuration file and launching it with argument fuzz --afl , it hits those breakpoints but I was unable to continue to debug because the function qemu._connect() will fail because of a socket error. It turns out the frontend python script is communicating to the QEMU instance via UNIX Socket as documented in the kAFL documentation.Doc├── interface_N                  - socket between kAFL worker N and Qemu NWe would love to debug the QEMU instance as wellAs you see in the screenshot above, I have commented out the subprocess which will start a new QEMU-Nyx process that boots our image. while QEMU provides useful stub -S, -s for pausing the VM image at it’s first vCPU execution, we would still love to pause the QEMU process at the initialization phase (i.e., Machine/CPU/Peripheral initializatio) which is the actual main() function in vl.c file (QEMU 4.2.0 release).So, we can tell the python script to pause at qemu.connect() and then start the QEMU-Nyx instance ourself -&gt; wait for the socket to listen for connection -&gt; continue the frontend fuzzer -&gt; we can now continue the debugging processTo achieve this, I leveraged debugpy which is what vscode uses under the hood for python debugging, to listen on a port at the begining of the start() function of QEMU python classAnd the configuration fileBuilding QEMU-Nyx yourselfIf you look at the repo QEMU-Nyx, you will see it included a .sh script to build the QEMU-Nyx with a few options Here is the actual flags being passed to configureThis is done so that we can get the full symbol for the qemu-system-x86_64 and start debugging with gdb.Putting it togetherFollow the procedure of building your vm image using vagrant and ansible playbook -&gt; start the fuzzer with kafl fuzz --purge -w /tmp/whatever  (-w for setting the working directory) -&gt; make sure the interface_0 unix socket exist in the folder, attach to the python script debugpy and start debugging."
  },
  
  {
    "title": "Stalking inside of your Chromium Browser",
    "url": "/posts/Stalking-Inside_of_Your_chromium_Browser/",
    "categories": "redteam",
    "tags": "",
    "date": "2022-12-01 00:00:00 -0600",
    





    
    "snippet": "Revisiting Remote DebuggingOkay, you got your favorite agent running on the target machine. You did a process listing, but nothing interesting popped out. You searched through every possible thing,...",
    "content": "Revisiting Remote DebuggingOkay, you got your favorite agent running on the target machine. You did a process listing, but nothing interesting popped out. You searched through every possible thing, even the trash bins to find a clue of where exactly the user hid their secrets that could get you to the user’s Azure portal.Well, Let’s revisit the process listing a little bit, do you see it? Is Chrome running with a bunch of child processes like this?Google Chrome ProcessesLook at that, the user is surfing the web with his/her favorite browser — Chrome!As a red teamer, I immediately thought of leveraging the remote debugging feature which is a built-in feature for all Chromium based browsers. This feature allows developers to troubleshoot using Chrome Remote Debugging Protocols (CDP) while they are doing the heavy lifting. A copy-paste description for CDP below.The Chrome DevTools Protocol allows for tools to instrument, inspect, debug and profile Chromium, Chrome and other Blink-based browsers. Instrumentation is divided into a number of domains (DOM, Debugger, Network etc.). Each domain defines a number of commands it supports and events it generates. Both commands and events are serialized JSON objects of a fixed structure.As red teamers, we can certainly abuse this feature to dump session cookies using the documented methodology by Justin Bui’s Hands in the Cookie Jar and an awesome python script called cookienapper.py written by Elliot Grey. But, what if the cookies expired? We just grabbed some spoiled cookies and we certainly can’t use them anywhere. Well, It will be nice if we can be notified when they log into Azure and refresh their cookies?To recap the technique used to dump cookies, we just need to quickly kill the Chrome process.kill ChromeprocessRestart it to enable remote debugging, restore the previous session and load the correct user profile.run \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --remote-debugging-port=9222 --user-data-dir=\"C:\\Users\\UserName\\AppData\\Local\\Google\\Chrome\\User Data\" --restore-last-sessionProxying [cookienapper.py](https://github.com/greycatsec/cookienapper) through a socks tunnel and profit!!socks 8081 socks5  proxychains4 python3 cookienapper.pyWe are almost there, but not yet. After inspecting the cookies we got from cookienapper, it turns out that the user was watching YouTube instead of working on Azure infrastructure deployments(a bad employee accidentally protected the company in an effortless way). So, the cookies we got were essentially useless.When will they start working !?Is there a way to possibly gather some information about users’ currently opened tabs without going through dumped cookies? It is mentioned in Hands in the Cookie Jar by Justin, the /json endpoint will provide us with more details of each opened tab.Information From /JSON EndpointThere are a couple of interesting fields that caught my eye, we can see the title of every tab the user has opened, and the url that the tab is currently browsing. Nice! We can sit here and refresh the “http://localhost:9222/json” page and filter out by title and URLs to see what the user is actually doing and hope the user will eventually log in to Azure so we can also enjoy the Azure cookies. Here, we can see the user is watching his/her favorite music video.There must be a better wayI eventually got tired of hitting the refresh button over and over, so I decided to look for alternative ways to monitor user activities. I revisited the cookienapper.py source code again and noticed that we were establishing a WebSocket connection to the “webSocketDebuggerUrl” and supplied a JSON string that looks like the following JSON{“id”:1, “method”:”Network.getAllCookies”}A quick google on the method “Network.getAllCookies” eventually led me to CDP documentation. It turns out, the method we were calling to dump cookies was just one of the commands supported by CDP.After going through some of the domains and methods provided in the document, I landed on the domain “Target”. The description of the domain says: “Supports additional target discovery and allows attaching to them.” After taking a closer look at the methods, there is one that caught my eyes called Target.setDiscoverTargets.Target.setDiscoverTargetsWhat is a “target”What are “targetCreated”, “targetInfoChanged”, “targetDestroyed”? In order to understand those, we must understand what is a “target”. This is a short conversation that explains “what is a target”, but I will also give my own understanding here. A “target” can be in the form of many types, such as “page”, or “iframe”. When you open a new tab in your browser, it creates a new blank “page” target, and when a page loads javascript, it creates a new “iframe” target. Each target will contain certain information about themselves such as “title”, “url”, “targetId” etc…When a new target is created, the “targetCreated” event is triggered. When a target’s information such as URL,or title changed, the “targetInfoChanged” event is triggered. When a target is destroyed, meaning the tabs are closed, the “targetDestroyed” event is triggered.Now what?After we understand the concept of “target”, the method will make much more sense. Essentially, If we keep the WebSocket alive long enough for the user to login to Azure, we will get tons of JSON response trigged from the above events.Let’s walk through them. The setup here I am using is Cobaltstrike socks5 proxy, a WebSocket client (wscat in this case). We can connect to a “webSocketDebuggerUrl” shown in “http://localhost:9222/json” that does not belong to a chrome-extension target (you can tell from the /json output url field, a chrome extension has a url with “chrome-extension://randomcharacters”).wscat -c ws://localhost:9222/devtools/page/7926E489B15E2BBE6531C458E4AE7232We will call the method with{“id”:2, “method”:”Target.setDiscoverTargets”, “params”:{“discover”:true}}We can see the WebSocket received a response with some more JSON strings containing information about all currently opened tabs and a result indicating the method has run successfully.Output from WebSocketWhen the user opens a new blank “target” page, the JSON response we will get from the WebSocket looks like this. We can see there are two methods called, “Target.targetCreated” and “Target.targetInfoChanged”.Output from WebSocketAnd when the user types “azure portal” in the url bar and hit Enter.User Searching “Azure Portal”We will get a couple more JSON responses that look like this.“Azure Portal” Keyword in Output from WebSocketAfter the user enetered the username to kick off the Oauth flow, we can also capture the username from the request URL.From the above response, we then know the user is currently logging into Azure and we can dump cookies again for fun and profit.More AutomationCool, so now we have a way to monitor user activity by asking the browser to give us live updates, but it will still require us to watch for the specific JSON response to really know when the user logins to something that we hope for.Is there a way to automate this? Of course. Here is a small PoC that I put together (heavily inspired by ntlmrelayx’s –socks flag) that will first send a GET request to “http://localhost:9222/json” on the remote host debugging port, create a WebSocket and connect to a “webSocketDebuggerUrl”. When you type “setDiscoveryTargets” and hit Enter, it will create a new thread that sends the “Target.setDiscoverTargets” command, listens for JSON responses and print them out by “type” and outputs useful information such as “URL”, and “title”. When you are ready to dump cookies, simply type “getCookies” and hit Enter, it will run cookienapper for you.Example Usage of agentChromium.pyThis is just a small PoC and there is more that can be done. For example, we can also add an event trigger that kicks off cookienapper when the title contains certain keywords.Detections  Detect Chrome processes created by a unusual process  Monitor for command line argument created with Chrome process to see if it is trying to enable remote debugging feature  A GET request sends to /json with a abnormal user-agentsConclusionTo conclude, chromium-based browsers have become the new favorite for red teamers. This is just a demonstration of how one can combine multiple commands supported by CDP to save time and increase efficiency in a red team engagement.There are lots of excellent projects that leverage remote debugging features to achieve different purposes, and there are still plenty of commands left unexplored.Thank you for taking the time to read this blog post of mine. I hope you learned something new from this!"
  }
  
]

